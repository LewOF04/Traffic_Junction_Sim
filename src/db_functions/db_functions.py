import openpyxl.worksheet
import openpyxl.worksheet.worksheet
from datetime import datetime
import sys
import hashlib
import os

import sqlite3

# from scipy.stats import norm
from sympy.stats import Normal, cdf
from sympy import N

import importlib
from inst import SQL


def init_db(path: str | os.PathLike="data/example.db", table: str | os.PathLike="inst/SQL/sample_create.sql"):
    """Initialize Database in default location

    Args:
        path (str, os.PathLike): The path to the database
        table (str, os.PathLike): The path to the query to create the table

    Returns: 
        None

    Raises:
        ValueError: Caused by invalid path
    """
    if not (os.path.exists(path) or os.path.exists(table)):
        raise ValueError("give a valid path")
    execute_inject_query(path, table)
    
def get_conn(path: str | os.PathLike) -> sqlite3.Connection:
    """get the sqlite3 connection object

    Args:
        path (str, os.PathLike): The path to the database

    Returns: 
        conn (sqlite3.Connection): An sqlite3 connection object
    """
    try:
        conn = sqlite3.connect(path)
        return conn
    except:
        return None
      
def get_cursor(conn: sqlite3.Connection) -> sqlite3.Cursor:
    """get the cursor object

    Args:
        conn (sqlite3.Connection): The connection object

    Returns: 
        cur (sqlite3.Cursor): A cursor object used to execute queries in sqlite3

    Raises:
        TypeError: conn must be a valid sqlite3.Connection object
    """
    if not isinstance(conn, sqlite3.Connection):
        raise TypeError
    try:
        cur = conn.cursor()
        return cur
    except:
        return None
        
def close_conn(conn: sqlite3.Connection) -> bool:
    """close the connection

    Args:
        conn (sqlite3.Connection): The sqlite3 connection object

    Returns: 
        bool (bool): True upon success, otherwise False

    Raises:
        TypeError: conn must be a valid sqlite3.Connection object
    """
    if not isinstance(conn, sqlite3.Connection):
        raise TypeError
    else:
        try:
            conn.close()
            return True
        except sqlite3.Error as e:
            print(e)
            return False
        except Exception as e:
            print(e)
            return False

### BEGIN SYMMETRY
def offset(lst: list, i: int) -> list:
    """Offset a list 

    Args:
        lst (list): The list that we want to offset
        i (int): The amount we want to offset by
    
    Returns:
        list: The offset list
    """
    if not (isinstance(lst, list) or isinstance(i, int)):
        raise TypeError("offset requires a list and an integer value as arguments")
    return lst[i:] + lst[:i]

def check_symmetry(params: dict) -> list[hashlib.sha256]:
    """Compute hash values generated by rotational symmetry of junctions
    
    Description:
        Calculate each hash value generated by equivalent junction configurations by considering the implications of rotational symmetry

    Args:
        params (dict): The dictionary with input parameters.

    Returns:
        list[hashlib.sha256]: A list of hash values for equivalent junction configurations.
    """
    if not isinstance(params, dict):
        raise ValueError("An invalid input type was given")

    index = [1, 2, 3, 4]
    out = []
    for i in range(4):
        a, b, c, d = offset(index, i)

        lanes_north = [ 
        f"traffic_left_{a}_{params.get('southbound_west_exit')}",
        f"traffic_straight_{a}_{params.get('southbound_south_exit')}",
        f"traffic_right_{a}_{params.get('southbound_east_exit')}",
        f"n_buses_{a}_{params.get('north_buses_per_hour')}",
        f"priority_{a}_{params.get('north_priority')}",
        f"lanes_left_right_{a}_{params.get('north_left_right_lane')}", 
        f"lanes_left_right_straight_{a}_{params.get('north_left_right_straight_lane')}", 
        f"lanes_straight_{a}_{params.get('north_straight_lane_count')}", 
        f"lanes_left_{a}_{params.get('north_left_lane_count')}", 
        f"lanes_left_straight_{a}_{params.get('north_straight_left_lane_count')}", 
        f"lanes_right_straight_{a}_{params.get('north_straight_right_lane_count')}", 
        f"lanes_right_{a}_{params.get('north_right_lane_count')}"]

        lanes_east = [ 
        f"traffic_left_{b}_{params.get('westbound_south_exit')}",
        f"traffic_straight_{b}_{params.get('westbound_west_exit')}",
        f"traffic_right_{b}_{params.get('westbound_north_exit')}",
        f"n_buses_{b}_{params.get('east_buses_per_hour')}",
        f"priority_{b}_{params.get('east_priority')}",
        f"lanes_left_right_{b}_{params.get('east_left_right_lane')}", 
        f"lanes_left_right_straight_{b}_{params.get('east_left_right_straight_lane')}", 
        f"lanes_straight_{b}_{params.get('east_straight_lane_count')}", 
        f"lanes_left_{b}_{params.get('east_left_lane_count')}", 
        f"lanes_left_straight_{b}_{params.get('east_straight_left_lane_count')}", 
        f"lanes_right_straight_{b}_{params.get('east_straight_right_lane_count')}", 
        f"lanes_right_{b}_{params.get('east_right_lane_count')}"]

        lanes_south = [ 
        f"traffic_left_{c}_{params.get('northbound_west_exit')}",
        f"traffic_straight_{c}_{params.get('northbound_north_exit')}",
        f"traffic_right_{c}_{params.get('northbound_east_exit')}",
        f"n_buses_{c}_{params.get('south_buses_per_hour')}",
        f"priority_{c}_{params.get('south_priority')}",
        f"lanes_left_right_{c}_{params.get('south_left_right_lane')}", 
        f"lanes_left_right_straight_{c}_{params.get('south_left_right_straight_lane')}", 
        f"lanes_straight_{c}_{params.get('south_straight_lane_count')}", 
        f"lanes_left_{c}_{params.get('south_left_lane_count')}", 
        f"lanes_left_straight_{c}_{params.get('south_straight_left_lane_count')}", 
        f"lanes_right_straight_{c}_{params.get('south_straight_right_lane_count')}", 
        f"lanes_right_{c}_{params.get('south_right_lane_count')}"]

        lanes_west = [ 
        f"traffic_left_{d}_{params.get('eastbound_north_exit')}",
        f"traffic_straight_{d}_{params.get('eastbound_east_exit')}",
        f"traffic_right_{d}_{params.get('eastbound_south_exit')}",
        f"n_buses_{d}_{params.get('west_buses_per_hour')}",
        f"priority_{d}_{params.get('west_priority')}",
        f"lanes_left_right_{d}_{params.get('west_left_right_lane')}", 
        f"lanes_left_right_straight_{d}_{params.get('west_left_right_straight_lane')}", 
        f"lanes_straight_{d}_{params.get('west_straight_lane_count')}", 
        f"lanes_left_{d}_{params.get('west_left_lane_count')}", 
        f"lanes_left_straight_{d}_{params.get('west_straight_left_lane_count')}", 
        f"lanes_right_straight_{d}_{params.get('west_straight_right_lane_count')}", 
        f"lanes_right_{d}_{params.get('west_right_lane_count')}"]

        pedestrian_crossing = f"crossing_{params.get('pedestrian_crossing', 0)}"
        pedestrian_crossing_duration = f"durations_{params.get('duration', 0)}" #edit
        crossing_requests_per_hour = f"crossing_requests_{params.get('crossing_requestsPH', 0)}"

        lst = sorted(lanes_north + lanes_east + lanes_south + lanes_west + [pedestrian_crossing_duration, crossing_requests_per_hour + pedestrian_crossing])

        pk = hashlib.sha256(bytes(str(lst), 'utf-8')).hexdigest()
        out.append(pk)

    # Idea: return max(out)
    # -> Depends on whether the return value needs to match with the input 1 <-> 1
    return out
### END SYMMETRY



### BEGIN QUERIES
def execute_inject_query(conn: sqlite3.Connection, query: str | os.PathLike, close_conn: bool =True, return_as_df=False, *args: any) -> sqlite3.Cursor | None:
    """Wrapper function for executing sql queries using sqlite3 in python.

    Description:
        Intended to handle parameterized sql queries for both read and write operations. 
        Can also handle queries that do not have any addtional parameters (in this case, leave args empty).
        The query can either be read from an external .sql file, or can be passed directly as an argument.
        
    Args:
        conn (sqlite3.Connection): The sqlite3 connection object
        query (str, os.PathLike): The sql query, or path to external .sql query
        close_conn (bool): Option to close the connection for write queries or leave it open for read queries. Default is True.
        *args (any, ...): the optional injection arguments

    Returns: 
        out (sqlite3.Cursor): Returns the cursor. 

    Raises:
        ValueError: Ensure that the query is either the path to a file or a string
        sqlite3.DatabaseError: Ensure that valid arguments are being passed
    """
    
    if not (isinstance(query, str) or isinstance(query, os.PathLike)):
        raise ValueError
       
    query_type = "path"
    try:
        if query[-4:].lower() != ".sql":
            query_type = "query"
    except:
        pass

    try:
        cur = get_cursor(conn)
        try:
            path = importlib.resources.files(SQL).joinpath(query)
            with open(path, 'r') as q:
                sql = q.read()
        except:
            try:
                if query_type == "path":
                    with open(query, 'r') as q:
                        sql = q.read()
                else:
                    sql = query
            except:
                raise Exception

        if return_as_df:
            raise DeprecationWarning("The return as DF function is deprecated")
            # out = pd.read_sql_query(query, conn)
        else:
            out = cur.execute(sql, args)
        conn.commit()
        return out
    
    except Exception as e:
        conn.rollback()      
        return "fail"
        #raise sqlite3.DatabaseError("An error occured when trying to execute the sql query on the database")
        
    finally:
        if close_conn:
            conn.close()

def execute_sql_file_noinject(db: str | os.PathLike, query: str | os.PathLike) -> bool:
    """Wrapper function for executing sql files or strings containing multiple queries.

    Description:
        Extension of the execute_inject_query function, for sql files that include multiple queries and do not requre additional arguments. 
        Mainly intended for the initial setup of the database.
        
    Args:
        db (str, os.PathLike): The path to the database
        query (str, os.PathLike): The sql query, or path to external .sql query

    Returns: 
        bool: True upon success, false otherwise. 

    Raises:
        ValueError: Ensure that the query is either the path to a file or a string
        sqlite3.DatabaseError: Ensure that valid arguments are being passed
    """

    if not (isinstance(db, str) or isinstance(db, os.PathLike)):
        raise ValueError
    
    if not (isinstance(query, str) or isinstance(query, os.PathLike)):
        raise ValueError
       
    query_type = "path"
    try:
        if query[-4:].lower() != ".sql":
            query_type = "query"
    except:
        pass

    
    conn = get_conn(db)
    cur = get_cursor(conn)

    try:
        path = importlib.resources.files(SQL).joinpath(query)
        with open(path, 'r') as q:
            sql = q.read()
            # print(sql)
    except:
        try:
            if query_type == "path":
                with open(query, 'r') as q:
                    sql = q.read()
            else:
                sql = query
        except Exception as e:
            raise FileNotFoundError(f"Failed to read the file {e}")
        
    try:
        cursor = cur.executescript(sql)
        conn.commit()
        return True
    except Exception as e:
        conn.rollback()
        raise sqlite3.DatabaseError(f"An error occured when communicating with the Database, {e}")
    finally:
        conn.close()
    


def create_subkey(d: dict):
    """Creates the subkey used by the <TODO> retrieve get_equivalent_junctions

    Args:
        d (dict): A dictionary of inbound and outbound traffic 

    Returns:
        s (str): The hash of the corresponding string
    """
    lst = []
    for i, j in d.items():
        if isinstance(j, dict):
            for k, v in j.items():
                lst.append(f"{i}_{k}_{v}")
        else:
            lst.append(f"{i}_{k}_{v}")

    sk = hashlib.sha256(bytes(str(sorted(lst)), 'utf-8')).hexdigest()

    return(sk)

def getZScore(waiting_time: int, mean: float, std: float) -> float:
    """Function to calculate Z Score for waiting time

    Assumptions:
        https://www.patonsinsurance.co.uk/how-long-to-you-spend-waiting-at-traffic-lights/#:~:text=While%20it%20might%20seem%20like%20an%20eternity%20waiting,or%20air%20conditioning%20or%20grabbing%20a%20quick%20snack.

    Args:
        waiting_time (int): The waiting time
        mean (int): The average waiting time at traffic lights, default is 75 seconds
        std (int):  The average standard deviation time at traffic lights, default is 15 seconds

    Returns:
        Percentile rank based on expected real-world waiting times.

    Examples:
        >>> print(getZScore(75))
        ... 50
    """
    if (waiting_time < 0):
        raise ValueError(
            "The waiting time must be non-negative"
        )

    n_dist = Normal('X', mean, std)
    prob = cdf(n_dist)(waiting_time)
    
    score = (1-prob) * 100
    return round(float(N(score)), 2)

def metaphor(d: dict) -> dict:
    # headings ={"north_lanes": "north", "east_lanes": "east", "south_lanes": "south", "west_lanes": "west"}
    headings_index = {"north": 1, "east": 2, "south": 3, "west": 4}
    

    out = {}
    for k, v in d.items():
        if d.get(k) is None or d.get(k) == '':
            d[k] = 0
        if d.get(k) == 'true':
            d[k] = 1
    
    for k, v in headings_index.items():
        out[v] = ["LR"] * int(d.get(f'{k}_left_right_lane', 0)) + ["LRS"] * int(d.get(f'{k}_left_right_straight_lane', 0)) + ["L"] * int(d.get(f'{k}_left_lane_count', 0)) +  ["R"] * int(d.get(f'{k}_right_lane_count', 0)) +  ["RS"] * int(d.get(f'{k}_straight_right_lane_count', 0)) +  ["LS"] * int(d.get(f'{k}_straight_left_lane_count', 0)) +  ["S"] * int(d.get(f'{k}_straight_lane_count', 0)) +  ["CB"] * int(max(d.get(f'{k}_bus_lane', 0), d.get(f'{k}_cycle_lane', 0)))

    out[5] = [int(d.get("southbound_west_exit", 0)), int(d.get("southbound_south_exit", 0)), int(d.get("southbound_east_exit", 0)), int(d.get("north_buses_per_hour", 0))]
    out[6] = [int(d.get("westbound_north_exit", 0)), int(d.get("westbound_west_exit", 0)), int(d.get("westbound_south_exit", 0)), int(d.get("east_buses_per_hour", 0))]
    out[7] = [int(d.get("northbound_east_exit", 0)), int(d.get("northbound_north_exit", 0)), int(d.get("northbound_west_exit", 0)), int(d.get("south_buses_per_hour", 0))]
    out[8] = [int(d.get("eastbound_south_exit", 0)), int(d.get("eastbound_east_exit", 0)), int(d.get("eastbound_north_exit", 0)), int(d.get("west_buses_per_hour", 0))]

    priority = [int(d.get('north_priority', 0)), int(d.get('east_priority', 0)), int(d.get('south_priority', 0)), int(d.get('west_priority', 0))]
    
    if priority != [0, 0, 0, 0] and 0 in priority:
        for i in range(0, len(priority)):
            if priority[i] == 0:
                priority[i] = 1

    
    if priority != [0, 0, 0, 0]:
        out[9] = True
        out[10] = priority
    else:
        out[9] = False
        out[10] = None

    out[11] = bool(d.get("pedestrian_crossing", False))
    out[12] = int(d.get("crossing_requests_PH", 0))
    out[13] = int(d.get("crossing_requests_duration", 0))

    return out

def get_pk(params: dict) -> list[hashlib.sha256]:
    """Compute hash values generated by rotational symmetry of junctions
   
    Description:
        Calculate each hash value generated by equivalent junction configurations by considering the implications of rotational symmetry
 
    Args:
        params (dict): The dictionary with input parameters.
 
    Returns:
        list[hashlib.sha256]: A list of hash values for equivalent junction configurations.
    """
    
    a, b, c, d =1, 2, 3, 4

    if not isinstance(params, dict):
        raise ValueError("An invalid input type was given")
 
    lanes_north = [
    f"traffic_left_{a}_{params.get('southbound_west_exit')}",
    f"traffic_straight_{a}_{params.get('southbound_south_exit')}",
    f"traffic_right_{a}_{params.get('southbound_east_exit')}",
    f"n_buses_{a}_{params.get('north_buses_per_hour')}",
    f"priority_{a}_{params.get('north_priority')}",
    f"lanes_left_right_{a}_{params.get('north_left_right_lane')}",
    f"lanes_left_right_straight_{a}_{params.get('north_left_right_straight_lane')}",
    f"lanes_straight_{a}_{params.get('north_straight_lane_count')}",
    f"lanes_left_{a}_{params.get('north_left_lane_count')}",
    f"lanes_left_straight_{a}_{params.get('north_straight_left_lane_count')}",
    f"lanes_right_straight_{a}_{params.get('north_straight_right_lane_count')}",
    f"lanes_right_{a}_{params.get('north_right_lane_count')}"]

    lanes_east = [
    f"traffic_left_{b}_{params.get('westbound_south_exit')}",
    f"traffic_straight_{b}_{params.get('westbound_west_exit')}",
    f"traffic_right_{b}_{params.get('westbound_north_exit')}",
    f"n_buses_{b}_{params.get('east_buses_per_hour')}",
    f"priority_{b}_{params.get('east_priority')}",
    f"lanes_left_right_{b}_{params.get('east_left_right_lane')}",
    f"lanes_left_right_straight_{b}_{params.get('east_left_right_straight_lane')}",
    f"lanes_straight_{b}_{params.get('east_straight_lane_count')}",
    f"lanes_left_{b}_{params.get('east_left_lane_count')}",
    f"lanes_left_straight_{b}_{params.get('east_straight_left_lane_count')}",
    f"lanes_right_straight_{b}_{params.get('east_straight_right_lane_count')}",
    f"lanes_right_{b}_{params.get('east_right_lane_count')}"]

    lanes_south = [
    f"traffic_left_{c}_{params.get('northbound_west_exit')}",
    f"traffic_straight_{c}_{params.get('northbound_north_exit')}",
    f"traffic_right_{c}_{params.get('northbound_east_exit')}",
    f"n_buses_{c}_{params.get('south_buses_per_hour')}",
    f"priority_{c}_{params.get('south_priority')}",
    f"lanes_left_right_{c}_{params.get('south_left_right_lane')}",
    f"lanes_left_right_straight_{c}_{params.get('south_left_right_straight_lane')}",
    f"lanes_straight_{c}_{params.get('south_straight_lane_count')}",
    f"lanes_left_{c}_{params.get('south_left_lane_count')}",
    f"lanes_left_straight_{c}_{params.get('south_straight_left_lane_count')}",
    f"lanes_right_straight_{c}_{params.get('south_straight_right_lane_count')}",
    f"lanes_right_{c}_{params.get('south_right_lane_count')}"]

    lanes_west = [
    f"traffic_left_{d}_{params.get('eastbound_north_exit')}",
    f"traffic_straight_{d}_{params.get('eastbound_east_exit')}",
    f"traffic_right_{d}_{params.get('eastbound_south_exit')}",
    f"n_buses_{d}_{params.get('west_buses_per_hour')}",
    f"priority_{d}_{params.get('west_priority')}",
    f"lanes_left_right_{d}_{params.get('west_left_right_lane')}",
    f"lanes_left_right_straight_{d}_{params.get('west_left_right_straight_lane')}",
    f"lanes_straight_{d}_{params.get('west_straight_lane_count')}",
    f"lanes_left_{d}_{params.get('west_left_lane_count')}",
    f"lanes_left_straight_{d}_{params.get('west_straight_left_lane_count')}",
    f"lanes_right_straight_{d}_{params.get('west_straight_right_lane_count')}",
    f"lanes_right_{d}_{params.get('west_right_lane_count')}"]

    pedestrian_crossing = f"crossing_{params.get('pedestrian_crossing', 0)}"
    pedestrian_crossing_duration = f"durations_{params.get('duration', 0)}" #edit
    crossing_requests_per_hour = f"crossing_requests_{params.get('crossing_requestsPH', 0)}"

    lst = sorted(lanes_north + lanes_east + lanes_south + lanes_west + [pedestrian_crossing_duration, crossing_requests_per_hour + pedestrian_crossing])

    pk = hashlib.sha256(bytes(str(lst), 'utf-8')).hexdigest()
 
    return pk



if __name__ == '__main__':
    pass
